---
globs: nextjs-website/*
alwaysApply: false
---
# Modern Next.js Data Fetching Patterns

## Overview

This project uses modern Next.js 15+ patterns for data fetching and state management. All API routes (except auth) have been migrated to Server Actions using [lib/safe-action.ts](mdc:lib/safe-action.ts).

## Data Fetching Hierarchy (Best to Worst)

### 1. Server Components with Direct Fetching (Best)

Use for initial page loads and static data:

```typescript
// ✅ GOOD: Server Component with direct data fetching
export default async function DashboardPage() {
  const session = await auth();
  const googleAdsData = await getUserGoogleAdsData(session.user.id);

  return (
    <div>
      <DashboardMetrics data={googleAdsData} />
      <GoogleAdsAccountSelector initialAccounts={googleAdsData.accounts} />
    </div>
  );
}
```

### 2. Server Actions with `useAction` (Best for mutations)

Use for user interactions and data updates:

```typescript
"use client";
import { useAction } from "next-safe-action/hooks";
import { selectGoogleAdsAccount } from "@/app/actions";

export function AccountSelector() {
  const { execute, result, status } = useAction(selectGoogleAdsAccount);

  const handleSelect = (accountId: string) => {
    execute({ accountId });
  };

  return (
    <Select onValueChange={handleSelect} disabled={status === "executing"}>
      {/* options */}
    </Select>
  );
}
```

### 3. React's `use()` Hook (Best for streaming)

Use for conditional data fetching and streaming:

```typescript
"use client";
import { use } from "react";

export function GoogleAdsAccountSelector() {
  const accountsPromise = getGoogleAdsAccounts({});
  const accounts = use(accountsPromise);

  return <Select>{/* render accounts */}</Select>;
}
```

### 4. Custom Hooks with SWR/TanStack Query (Best for real-time)

Use only when you need frequent updates or complex caching:

```typescript
import useSWR from "swr";

export function useGoogleAdsAccounts() {
  const { data, error, mutate } = useSWR(
    "google-ads-accounts",
    () => getGoogleAdsAccounts({}),
    { refreshInterval: 30000 }
  );

  return {
    accounts: data?.data?.accounts || [],
    error,
    isLoading: !data && !error,
  };
}
```

### 5. useEffect (Avoid - Last Resort)

Only use for browser-only APIs or when no other pattern works:

```typescript
// ❌ AVOID: Traditional useEffect pattern
useEffect(() => {
  fetch("/api/google-ads/accounts")
    .then((res) => res.json())
    .then(setAccounts);
}, []);
```

## Server Actions Pattern

### Using [lib/safe-action.ts](mdc:lib/safe-action.ts)

All Server Actions use the `authAction` wrapper for type safety:

```typescript
// ✅ GOOD: Using safe-action pattern
export const getGoogleAdsAccounts = authAction(
  z.object({}),
  async ({ ctx }) => {
    const { session } = ctx;
    const api = createGoogleAdsAPI();
    api.setCredentials(session.accessToken, session.refreshToken);
    const accounts = await api.getCustomerAccounts();
    return { accounts };
  }
);
```

### Error Handling

Server Actions return structured results:

```typescript
const result = await getGoogleAdsAccounts({});

if (result.data?.error) {
  // Handle validation/application error
  setError(result.data.error);
} else if (result.serverError) {
  // Handle server error
  setError(result.serverError);
} else if (result.data?.accounts) {
  // Success case
  setAccounts(result.data.accounts);
}
```

## next-safe-action Hooks

### `useAction` Hook

Use for managing action state and pending states:

```typescript
"use client";
import { useAction } from "next-safe-action/hooks";
import { selectGoogleAdsAccount } from "@/app/actions";

export function AccountSelector() {
  const { execute, result, status } = useAction(selectGoogleAdsAccount);

  const handleSelect = (accountId: string) => {
    execute({ accountId });
  };

  return (
    <div>
      <Select onValueChange={handleSelect} disabled={status === "executing"}>
        {/* options */}
      </Select>
      {status === "executing" && <Loader2 className="animate-spin" />}
      {result?.data?.success && <CheckCircle />}
      {result?.data?.error && <Alert>{result.data.error}</Alert>}
    </div>
  );
}
```

### `useActionState` Hook (for stateful actions)

Use when you need to access previous action results. Import from React:

```typescript
"use client";
import { useActionState } from "react";
import { incrementCounter } from "@/app/actions";

export function Counter() {
  const [state, action, pending] = useActionState(incrementCounter, 0);

  const handleIncrement = () => {
    action({ increment: 1 });
  };

  return (
    <div>
      <p>Count: {state}</p>
      <Button onClick={handleIncrement} disabled={pending}>
        {pending ? "Incrementing..." : "Increment"}
      </Button>
    </div>
  );
}
```

### `useOptimisticAction` Hook (for optimistic updates)

Use for optimistic updates that don't wait for server response:

```typescript
"use client";
import { useOptimisticAction } from "next-safe-action/hooks";
import { addTodo, type Todo } from "@/app/actions";

export function TodosBox({ todos }: { todos: Todo[] }) {
  const { execute, result, optimisticState } = useOptimisticAction(addTodo, {
    currentState: { todos },
    updateFn: (state, newTodo) => {
      return {
        todos: [...state.todos, newTodo],
      };
    },
  });

  return (
    <div>
      <button
        onClick={() => {
          execute({
            id: crypto.randomUUID(),
            body: "New Todo",
            completed: false,
          });
        }}
      >
        Add todo
      </button>
      <pre>Optimistic state: {optimisticState}</pre>
    </div>
  );
}
```

### Stateful Action Definition

For `useActionState`, define actions with `stateAction`:

```typescript
// ✅ GOOD: Stateful action for useActionState
export const incrementCounter = authAction.stateAction(
  z.object({ increment: z.number() }),
  async ({ parsedInput: { increment }, ctx }, { prevResult }) => {
    const newCount = (prevResult || 0) + increment;
    return newCount;
  }
);
```

## Form Handling with Server Actions

### Using `useAction` for Forms

```typescript
"use client";
import { useAction } from "next-safe-action/hooks";
import { createAccount } from "@/app/actions";

export function AccountForm() {
  const { execute, result, status } = useAction(createAccount);

  const handleSubmit = (formData: FormData) => {
    const name = formData.get("name") as string;
    execute({ name });
  };

  return (
    <form action={handleSubmit}>
      <input name="name" required />
      <button type="submit" disabled={status === "executing"}>
        {status === "executing" ? "Creating..." : "Create Account"}
      </button>
      {result?.data?.error && <Alert>{result.data.error}</Alert>}
    </form>
  );
}
```

### Using `useActionState` for Multi-step Forms

```typescript
"use client";
import { useActionState } from "react";
import { updateUserProfile } from "@/app/actions";

export function ProfileForm({ initialData }) {
  const [state, action, pending] = useActionState(
    updateUserProfile,
    initialData
  );

  const handleUpdate = (updates) => {
    action(updates);
  };

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        const formData = new FormData(e.currentTarget);
        handleUpdate(Object.fromEntries(formData));
      }}
    >
      <input name="name" defaultValue={state?.name} />
      <button type="submit" disabled={pending}>
        {pending ? "Updating..." : "Update Profile"}
      </button>
    </form>
  );
}
```

## Optimistic Updates

### Using `useOptimisticAction` with Server Actions

```typescript
"use client";
import { useOptimisticAction } from "next-safe-action/hooks";
import { updateCampaign } from "@/app/actions";

export function CampaignList({ campaigns }) {
  const { execute, result, optimisticState } = useOptimisticAction(
    updateCampaign,
    {
      currentState: { campaigns },
      updateFn: (state, newCampaign) => ({
        campaigns: state.campaigns.map((c) =>
          c.id === newCampaign.id ? { ...c, ...newCampaign } : c
        ),
      }),
    }
  );

  const handleUpdate = (campaignId, updates) => {
    execute({ campaignId, ...updates });
  };

  return (
    <div>
      {optimisticState.campaigns.map((campaign) => (
        <CampaignItem
          key={campaign.id}
          campaign={campaign}
          onUpdate={handleUpdate}
        />
      ))}
    </div>
  );
}
```

## Error Handling Patterns

### Comprehensive Error Handling

```typescript
"use client";
import { useAction } from "next-safe-action/hooks";
import { selectGoogleAdsAccount } from "@/app/actions";

export function AccountSelector() {
  const { execute, result, status } = useAction(selectGoogleAdsAccount);

  const handleSelect = (accountId: string) => {
    execute({ accountId });
  };

  // Handle different types of errors
  const error = result?.data?.error || result?.serverError;
  const success = result?.data?.success;
  const isLoading = status === "executing";

  return (
    <div>
      <Select onValueChange={handleSelect} disabled={isLoading}>
        {/* options */}
      </Select>

      {isLoading && (
        <div className="flex items-center">
          <Loader2 className="h-4 w-4 animate-spin mr-2" />
          <span>Updating...</span>
        </div>
      )}

      {success && (
        <div className="flex items-center text-green-600">
          <CheckCircle className="h-4 w-4 mr-2" />
          <span>Account selected successfully</span>
        </div>
      )}

      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
    </div>
  );
}
```

## Parallel Data Fetching

Use `Promise.all()` for multiple data sources:

```typescript
// ✅ GOOD: Parallel data fetching
const [googleAdsData, recommendations, abTests] = await Promise.all([
  getUserGoogleAdsData(session.user.id),
  getRecommendations(session.user.id),
  getABTests(session.user.id),
]);
```

## Streaming with Suspense

Use Suspense boundaries for progressive loading:

```typescript
export default function DashboardPage() {
  return (
    <div>
      <Suspense fallback={<DashboardMetricsSkeleton />}>
        <DashboardMetrics />
      </Suspense>

      <Suspense fallback={<CampaignTableSkeleton />}>
        <CampaignTable />
      </Suspense>
    </div>
  );
}

// Separate async components
async function DashboardMetrics() {
  const data = await getUserGoogleAdsData();
  return <DashboardMetrics data={data} />;
}
```

## Migration Strategy

### From API Routes to Server Actions

1. **Phase 1**: Convert GET operations to Server Components or `use()` hook
2. **Phase 2**: Convert POST/PUT/DELETE operations to Server Actions
3. **Phase 3**: Update components to use new patterns
4. **Phase 4**: Remove old API routes

### From useEffect to Modern Patterns

1. **Initial data**: Move to Server Components
2. **User interactions**: Use Server Actions with `useAction`
3. **Real-time updates**: Use SWR/TanStack Query
4. **Conditional fetching**: Use React's `use()` hook

## File Organization

### Server Actions

- All actions in [app/actions.ts](mdc:app/actions.ts)
- Grouped by domain (campaigns, accounts, recommendations, AI)
- Use descriptive names with action suffix

### Data Fetching Functions

- Database queries in [lib/fetchers.ts](mdc:lib/fetchers.ts)
- External API calls in [lib/google-ads.ts](mdc:lib/google-ads.ts)
- Use descriptive names starting with `get`, `create`, `update`, `delete`

### Components

- Server Components: No "use client" directive
- Client Components: Minimal "use client" boundaries
- Pass data as props from Server Components to Client Components

## Performance Guidelines

### Bundle Size

- Keep Client Components small and focused
- Use dynamic imports for heavy libraries
- Tree-shake unused imports

### Caching

- Use Next.js built-in caching for Server Components
- Implement proper cache invalidation with `revalidatePath`
- Use SWR/TanStack Query for client-side caching when needed

### Loading States

- Always provide loading states for async operations
- Use Suspense boundaries for streaming
- Implement proper error boundaries

## Common Patterns

### Form Handling

```typescript
"use client";
import { useAction } from "next-safe-action/hooks";

export function AccountForm() {
  const { execute, result, status } = useAction(createAccount);

  const handleSubmit = (formData: FormData) => {
    const name = formData.get("name") as string;
    execute({ name });
  };

  return (
    <form action={handleSubmit}>
      <input name="name" required />
      <button type="submit" disabled={status === "executing"}>
        {status === "executing" ? "Creating..." : "Create Account"}
      </button>
    </form>
  );
}
```

### Optimistic Updates

```typescript
"use client";
import { useOptimisticAction } from "next-safe-action/hooks";

export function AccountList({ accounts }) {
  const { execute, optimisticState } = useOptimisticAction(createAccount, {
    currentState: { accounts },
    updateFn: (state, newAccount) => ({
      accounts: [...state.accounts, newAccount],
    }),
  });

  const handleAdd = (account) => {
    execute(account);
  };
}
```

## When to Use Each Pattern

| Use Case              | Pattern                        | Example                                                                                |
| --------------------- | ------------------------------ | -------------------------------------------------------------------------------------- |
| Initial page data     | Server Component               | [app/page.tsx](mdc:app/page.tsx)                                                       |
| User interactions     | Server Action + useAction      | [components/GoogleAdsAccountSelector.tsx](mdc:components/GoogleAdsAccountSelector.tsx) |
| Stateful interactions | Server Action + useActionState | Multi-step forms, counters                                                             |
| Real-time updates     | SWR/TanStack Query             | Custom hooks                                                                           |
| Conditional data      | React use() hook               | Streaming components                                                                   |
| Browser APIs          | useEffect                      | Geolocation, localStorage                                                              |
| File uploads          | API Route                      | File upload endpoints                                                                  |

## Anti-Patterns to Avoid

1. **useEffect for initial data fetching** - Use Server Components instead
2. **Large Client Components** - Keep "use client" boundaries minimal
3. **API routes for internal operations** - Use Server Actions instead
4. **Manual fetch calls** - Use Server Actions or `use()` hook
5. **State management for server data** - Pass data as props
6. **Not using execute function** - Always call execute directly
7. **Ignoring loading states** - Always show loading indicators

## Testing Considerations

- Test Server Actions with [lib/safe-action.ts](mdc:lib/safe-action.ts) validation
- Mock external APIs in tests
- Test error states and loading states
- Use React Testing Library for component tests
- Test Server Components with async data fetching
- Test optimistic updates and state management
