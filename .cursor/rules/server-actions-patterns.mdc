# Server Actions Patterns

## Overview

This project uses Next.js 15+ Server Actions as the primary backend architecture. All business logic, data mutations, and API operations are implemented as Server Actions using modern patterns and best practices.

## Core Architecture

### Server Actions Implementation

All Server Actions follow the `next-safe-action` v8 pattern for type safety and error handling:

```typescript
// Example Server Action
import { authAction } from "@/lib/safe-action";
import { z } from "zod";

export const createUser = authAction
  .metadata({ actionName: "createUser" })
  .inputSchema(
    z.object({
      email: z.string().email(),
      name: z.string().min(1),
    })
  )
  .action(async ({ parsedInput, ctx }) => {
    // Business logic here
    const user = await db.users.create({
      data: parsedInput,
      userId: ctx.user.id,
    });

    return { success: true, user };
  });
```

### Action Categories

#### Authentication Actions

- User registration and login
- OAuth provider integration
- Session management
- Password reset and email verification

#### User Management

- Profile updates and preferences
- Account settings and security
- User data management
- Account deletion and cleanup

#### Data Operations

- CRUD operations for all entities
- Batch operations and bulk updates
- Data validation and transformation
- File uploads and media management

#### Business Logic

- Complex workflows and processes
- Integration with third-party services
- Analytics and reporting
- Notification and communication

## Integration Patterns

### Form Integration

Server Actions integrate seamlessly with the universal form system:

```typescript
// In your form component
import { useAction } from "next-safe-action/hooks";
import { submitForm } from "@/app/actions";

const { execute, result, status } = useAction(submitForm);

// Handle form submission
const handleSubmit = async (formData: FormData) => {
  const result = await execute({
    email: formData.get("email"),
    name: formData.get("name"),
  });

  if (result.data) {
    // Success handling
  } else {
    // Error handling
  }
};
```

### Real-time Updates

Server Actions support optimistic updates and real-time data synchronization:

```typescript
// Optimistic update pattern
const { execute } = useAction(updateUser, {
  onSuccess: (data) => {
    // Update local state optimistically
    updateUserAtom.set(data.user);
  },
  onError: (error) => {
    // Revert optimistic update
    revertUserAtom.set(previousUser);
  },
});
```

## Error Handling

### Standardized Error Responses

All Server Actions return consistent error structures:

```typescript
interface ActionError {
  code: string;
  message: string;
  details?: any;
  timestamp: string;
}
```

### Error Categories

- **Validation Errors**: Input validation failures
- **Authentication Errors**: Auth and permission issues
- **Business Logic Errors**: Domain-specific rule violations
- **System Errors**: Infrastructure and technical issues

## Performance Optimization

### Caching Strategy

Server Actions support intelligent caching:

```typescript
import { unstable_cache } from "next/cache";

export const getUserData = authAction.action(async ({ ctx }) => {
  return await unstable_cache(
    async () => {
      return await db.users.findUnique({
        where: { id: ctx.user.id },
        include: { profile: true },
      });
    },
    [`user-${ctx.user.id}`],
    { revalidate: 300 } // 5 minutes
  )();
});
```

### Batch Operations

Efficient handling of multiple operations:

```typescript
export const batchUpdateUsers = authAction
  .inputSchema(
    z.array(
      z.object({
        id: z.string(),
        updates: z.object({}),
      })
    )
  )
  .action(async ({ parsedInput }) => {
    return await db.$transaction(
      parsedInput.map(({ id, updates }) =>
        db.users.update({ where: { id }, data: updates })
      )
    );
  });
```

## Security Patterns

### Authentication & Authorization

All Server Actions use the `authAction` wrapper for security:

```typescript
export const sensitiveOperation = authAction
  .metadata({ actionName: "sensitiveOperation" })
  .inputSchema(z.object({}))
  .action(async ({ ctx }) => {
    // ctx.user is guaranteed to exist
    // ctx.session contains session data
    // Perform authorized operations
  });
```

### Input Validation

Comprehensive validation using Zod schemas:

```typescript
const userSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1).max(100),
  age: z.number().min(18).max(120),
  preferences: z
    .object({
      theme: z.enum(["light", "dark"]),
      notifications: z.boolean(),
    })
    .optional(),
});
```

## Testing Patterns

### Unit Testing

Server Actions can be tested in isolation:

```typescript
import { createUser } from "@/app/actions";

describe("createUser", () => {
  it("should create a user successfully", async () => {
    const mockCtx = { user: { id: "test-user" } };
    const result = await createUser.action({
      parsedInput: { email: "test@example.com", name: "Test User" },
      ctx: mockCtx,
    });

    expect(result.data).toBeDefined();
  });
});
```

### Integration Testing

End-to-end testing with form integration:

```typescript
import { render, screen, fireEvent } from "@testing-library/react";
import { useAction } from "next-safe-action/hooks";

// Mock the action
jest.mock("@/app/actions", () => ({
  createUser: { action: jest.fn() },
}));

// Test form submission
test("form submission calls server action", async () => {
  render(<UserForm />);

  fireEvent.click(screen.getByText("Submit"));

  expect(createUser.action).toHaveBeenCalledWith({
    parsedInput: { email: "test@example.com", name: "Test" },
    ctx: expect.any(Object),
  });
});
```

## Best Practices

### Action Organization

- **Group related actions** in domain-specific files
- **Use descriptive action names** that reflect the business operation
- **Keep actions focused** on single responsibilities
- **Document complex actions** with clear comments

### Performance Considerations

- **Use caching** for read operations
- **Implement optimistic updates** for better UX
- **Batch operations** when possible
- **Monitor action performance** and optimize slow operations

### Error Handling

- **Provide meaningful error messages** to users
- **Log errors** for debugging and monitoring
- **Implement retry logic** for transient failures
- **Handle edge cases** gracefully

### Security

- **Validate all inputs** using Zod schemas
- **Use authentication** for all sensitive operations
- **Implement rate limiting** for public actions
- **Sanitize data** before database operations

## Migration Guide

### From API Routes

1. **Identify API routes** that need migration
2. **Convert to Server Actions** using the patterns above
3. **Update client code** to use `useAction` hooks
4. **Test thoroughly** for functionality and performance
5. **Remove old API routes** once migration is complete

### From Custom Hooks

1. **Replace custom hooks** with Server Actions
2. **Update form components** to use `useAction`
3. **Implement optimistic updates** where beneficial
4. **Add proper error handling** and loading states

## References

- [Next.js Server Actions Documentation](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions)
- [next-safe-action Documentation](https://next-safe-action.vercel.app/)
- [Universal Form System](mdc:universal-form-system.mdc)
- [Backend API Architecture](mdc:backend-api.mdc)

- Use Drizzle ORM for database operations
- Implement proper error handling
- Use revalidatePath/revalidateTag for cache invalidation
- Scope operations to company context
