---
globs: nextjs-website/*
alwaysApply: false
---

# next-safe-action Hooks Usage

## Overview

This project uses `next-safe-action` v8 for type-safe Server Actions. The hooks are imported from `next-safe-action/hooks`.

## Available Hooks

### `useAction` Hook

Use for managing action state and pending states. Import from next-safe-action:

```typescript
"use client";
import { useAction } from "next-safe-action/hooks";
import { selectGoogleAdsAccount } from "@/app/actions";

export function AccountSelector() {
  const { execute, result, status } = useAction(selectGoogleAdsAccount);

  const handleSelect = (accountId: string) => {
    // Call the execute function with arguments
    execute({ accountId });
  };

  const isLoading = status === "executing";

  return (
    <div>
      <Select onValueChange={handleSelect} disabled={isLoading}>
        {/* options */}
      </Select>
      {isLoading && <Loader2 className="animate-spin" />}
      {result?.data?.success && <CheckCircle />}
      {result?.data?.error && <Alert>{result.data.error}</Alert>}
    </div>
  );
}
```

### `useActionState` Hook (for stateful actions)

Use when you need to access previous action results. Import from React (not next-safe-action):

```typescript
"use client";
import { useActionState } from "react";
import { incrementCounter } from "@/app/actions";

export function Counter() {
  const [state, action, pending] = useActionState(incrementCounter, 0);

  const handleIncrement = () => {
    // Call the action directly with arguments
    action({ increment: 1 });
  };

  return (
    <div>
      <p>Count: {state}</p>
      <Button onClick={handleIncrement} disabled={pending}>
        {pending ? "Incrementing..." : "Increment"}
      </Button>
    </div>
  );
}
```

### `useOptimisticAction` Hook (for optimistic updates)

Use for optimistic updates that don't wait for server response:

```typescript
"use client";
import { useOptimisticAction } from "next-safe-action/hooks";
import { addTodo, type Todo } from "@/app/actions";

export function TodosBox({ todos }: { todos: Todo[] }) {
  const { execute, result, optimisticState } = useOptimisticAction(addTodo, {
    currentState: { todos },
    updateFn: (state, newTodo) => {
      return {
        todos: [...state.todos, newTodo],
      };
    },
  });

  return (
    <div>
      <button
        onClick={() => {
          execute({
            id: crypto.randomUUID(),
            body: "New Todo",
            completed: false,
          });
        }}
      >
        Add todo
      </button>
      <pre>Optimistic state: {optimisticState}</pre>
    </div>
  );
}
```

## Server Action Definition

### Regular Actions (for useAction)

```typescript
// ✅ GOOD: Regular action for useAction
export const selectGoogleAdsAccount = authAction(
  z.object({
    accountId: z.string().min(1),
  }),
  async ({ input, ctx }) => {
    const { accountId } = input;
    const { session } = ctx;

    try {
      await prisma.user.update({
        where: { id: session.user.id },
        data: { selectedGoogleAdsAccountId: accountId },
      });

      return { success: true, selectedAccountId: accountId };
    } catch (error) {
      console.error("Error selecting Google Ads account:", error);
      return { error: "Failed to select account" };
    }
  }
);
```

### Stateful Actions (for useActionState)

```typescript
// ✅ GOOD: Stateful action for useActionState
export const incrementCounter = authAction.stateAction(
  z.object({ increment: z.number() }),
  async ({ parsedInput: { increment }, ctx }, { prevResult }) => {
    const newCount = (prevResult || 0) + increment;
    return newCount;
  }
);
```

## Hook Callbacks

You can pass callbacks to hooks for custom logic:

```typescript
const action = useAction(testAction, {
  onExecute: ({ input }) => {
    console.log("Action started with input:", input);
  },
  onSuccess: ({ data, input }) => {
    console.log("Action succeeded:", data);
  },
  onError: ({ error, input }) => {
    console.log("Action failed:", error);
  },
  onSettled: ({ result, input }) => {
    console.log("Action settled:", result);
  },
});
```

## Error Handling Patterns

### Comprehensive Error Handling with useAction

```typescript
"use client";
import { useAction } from "next-safe-action/hooks";
import { selectGoogleAdsAccount } from "@/app/actions";

export function AccountSelector() {
  const { execute, result, status } = useAction(selectGoogleAdsAccount);

  const handleSelect = (accountId: string) => {
    execute({ accountId });
  };

  // Handle different types of errors
  const error = result?.data?.error || result?.serverError;
  const success = result?.data?.success;
  const isLoading = status === "executing";

  return (
    <div>
      <Select onValueChange={handleSelect} disabled={isLoading}>
        {/* options */}
      </Select>

      {isLoading && (
        <div className="flex items-center">
          <Loader2 className="h-4 w-4 animate-spin mr-2" />
          <span>Updating...</span>
        </div>
      )}

      {success && (
        <div className="flex items-center text-green-600">
          <CheckCircle className="h-4 w-4 mr-2" />
          <span>Account selected successfully</span>
        </div>
      )}

      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
    </div>
  );
}
```

## Form Handling

### Using `useAction` for Forms

```typescript
"use client";
import { useAction } from "next-safe-action/hooks";
import { createAccount } from "@/app/actions";

export function AccountForm() {
  const { execute, result, status } = useAction(createAccount);

  const handleSubmit = (formData: FormData) => {
    const name = formData.get("name") as string;
    execute({ name });
  };

  const isLoading = status === "executing";

  return (
    <form action={handleSubmit}>
      <input name="name" required />
      <button type="submit" disabled={isLoading}>
        {isLoading ? "Creating..." : "Create Account"}
      </button>
      {result?.data?.error && <Alert>{result.data.error}</Alert>}
    </form>
  );
}
```

### Using `useActionState` for Multi-step Forms

```typescript
"use client";
import { useActionState } from "react";
import { updateUserProfile } from "@/app/actions";

export function ProfileForm({ initialData }) {
  const [state, action, pending] = useActionState(
    updateUserProfile,
    initialData
  );

  const handleUpdate = (updates) => {
    action(updates);
  };

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        const formData = new FormData(e.currentTarget);
        handleUpdate(Object.fromEntries(formData));
      }}
    >
      <input name="name" defaultValue={state?.name} />
      <button type="submit" disabled={pending}>
        {pending ? "Updating..." : "Update Profile"}
      </button>
    </form>
  );
}
```

## Optimistic Updates

### Using `useOptimisticAction` with Server Actions

```typescript
"use client";
import { useOptimisticAction } from "next-safe-action/hooks";
import { updateCampaign } from "@/app/actions";

export function CampaignList({ campaigns }) {
  const { execute, result, optimisticState } = useOptimisticAction(
    updateCampaign,
    {
      currentState: { campaigns },
      updateFn: (state, newCampaign) => ({
        campaigns: state.campaigns.map((c) =>
          c.id === newCampaign.id ? { ...c, ...newCampaign } : c
        ),
      }),
    }
  );

  const handleUpdate = (campaignId, updates) => {
    execute({ campaignId, ...updates });
  };

  return (
    <div>
      {optimisticState.campaigns.map((campaign) => (
        <CampaignItem
          key={campaign.id}
          campaign={campaign}
          onUpdate={handleUpdate}
        />
      ))}
    </div>
  );
}
```

## Key Differences from Traditional Patterns

### ❌ Don't use startTransition

```typescript
// ❌ WRONG: Don't wrap in startTransition
const handleSelect = (accountId: string) => {
  startTransition(() => {
    execute({ accountId });
  });
};
```

### ✅ Call execute function directly

```typescript
// ✅ CORRECT: Call execute directly
const handleSelect = (accountId: string) => {
  execute({ accountId });
};
```

### ❌ Don't await the execute function

```typescript
// ❌ WRONG: Don't await the execute function
const handleSelect = async (accountId: string) => {
  const result = await execute({ accountId });
};
```

### ✅ Let the hook handle the async behavior

```typescript
// ✅ CORRECT: Let the hook handle async behavior
const handleSelect = (accountId: string) => {
  execute({ accountId });
};
```

## When to Use Each Hook

| Use Case            | Hook                | Import From            | Example                    |
| ------------------- | ------------------- | ---------------------- | -------------------------- |
| Form submissions    | useAction           | next-safe-action/hooks | Account creation, updates  |
| User interactions   | useAction           | next-safe-action/hooks | Button clicks, selections  |
| Stateful operations | useActionState      | react                  | Counters, multi-step forms |
| Optimistic updates  | useOptimisticAction | next-safe-action/hooks | Real-time UI updates       |

## Common Patterns

### Multiple Actions in One Component

```typescript
"use client";
import { useAction } from "next-safe-action/hooks";
import { getGoogleAdsAccounts, selectGoogleAdsAccount } from "@/app/actions";

export function AccountSelector() {
  const {
    execute: loadAccountsExecute,
    result: accountsResult,
    status: accountsStatus,
  } = useAction(getGoogleAdsAccounts);
  const {
    execute: selectAccountExecute,
    result: selectResult,
    status: selectStatus,
  } = useAction(selectGoogleAdsAccount);

  const handleLoadAccounts = () => {
    loadAccountsExecute({});
  };

  const handleSelectAccount = (accountId: string) => {
    selectAccountExecute({ accountId });
  };

  const accountsLoading = accountsStatus === "executing";
  const selectLoading = selectStatus === "executing";

  return (
    <div>
      <Button onClick={handleLoadAccounts} disabled={accountsLoading}>
        {accountsLoading ? "Loading..." : "Load Accounts"}
      </Button>

      <Select onValueChange={handleSelectAccount} disabled={selectLoading}>
        {/* options */}
      </Select>
    </div>
  );
}
```

## Testing Considerations

- Test action state changes
- Test loading states (status === "executing")
- Test error handling
- Test optimistic updates
- Mock Server Actions in tests
- Test form submissions
